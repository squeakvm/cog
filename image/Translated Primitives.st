'From Croquet1.0beta of 11 April 2006 [latest update: #1] on 23 May 2010 at 4:41:30 pm'!!ADPCMCodec methodsFor: 'private' stamp: 'zz (auto pragmas 12/08) 3/2/2004 07:58'!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash actually computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	<inline: true>	diff := nextSample - thisSample.	diff < 0 ifTrue: [diff := 0 - diff].	bestIndex := 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex := j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm (auto pragmas 12/08) 3/28/1999 16:24'!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	<inline: true>	result := 0.	remaining := n.	[true] whileTrue: [		shift := remaining - bitPosition.		result := result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining := remaining - bitPosition.							currentByte := (encodedBytes at: (byteIndex := byteIndex + 1)).				bitPosition := 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition := bitPosition - remaining.				"mask out the consumed bits:"				currentByte := currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]].! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm (auto pragmas 12/08) 3/28/1999 20:21'!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	<inline: true>	buf := anInteger.	bufBits := n.	[true] whileTrue: [		bitsAvailable := 8 - bitPosition.		shift := bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte := currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte.				bitPosition := 0.				currentByte := 0.				"clear saved high bits of buf:"				buf := buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits := bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition := bitPosition + bufBits.				^ self]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted := self nextBits: 16.				predicted > 32767 ifTrue: [predicted := predicted - 65536].				index := self nextBits: 6.				samples at: (sampleIndex := sampleIndex + 1) put: predicted]			ifFalse: [				delta := self nextBits: bitsPerSample.				step := stepSizeTable at: index + 1.				predictedDelta := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta := predictedDelta + step].					step := step bitShift: -1.					bit := bit bitShift: -1].				predictedDelta := predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted := predicted - predictedDelta]					ifFalse: [predicted := predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted := 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].				index := index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index := 0]					ifFalse: [index > 88 ifTrue: [index := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	<var: #rightSamples declareC: 'short int *rightSamples'>	<var: #predicted declareC: 'short int *predicted'>	<var: #index declareC: 'short int *index'>	"make local copies of decoder state variables"	predictedLeft := predicted at: 1.	predictedRight := predicted at: 2.	indexLeft := index at: 1.	indexRight := index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft := self nextBits: 16.				indexLeft := self nextBits: 6.				predictedRight := self nextBits: 16.				indexRight := self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft := predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight := predictedRight - 65536].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft := self nextBits: bitsPerSample.				deltaRight := self nextBits: bitsPerSample.				stepLeft := stepSizeTable at: indexLeft + 1.				stepRight := stepSizeTable at: indexRight + 1.				predictedDeltaLeft := predictedDeltaRight := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft := predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight := predictedDeltaRight + stepRight].					stepLeft := stepLeft bitShift: -1.					stepRight := stepRight bitShift: -1.					bit := bit bitShift: -1].				predictedDeltaLeft := predictedDeltaLeft + stepLeft.				predictedDeltaRight := predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft := predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft := predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight := predictedRight - predictedDeltaRight]					ifFalse: [predictedRight := predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft := 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft := -32768]].				predictedRight > 32767					ifTrue: [predictedRight := 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight := -32768]].				indexLeft := indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft := 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft := 88]].				indexRight := indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight := 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:11'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	step := stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted := samples at: (sampleIndex := sampleIndex + 1).			(p := predicted) < 0 ifTrue: [p := p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index := self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign := 0.			diff := (samples at: (sampleIndex := sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign := deltaSignMask.				diff := 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta := (4 * diff) / step.				predictedDelta := ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta := 0.			predictedDelta := 0.			bit := deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta := delta + bit.					predictedDelta := predictedDelta + step.					diff := diff - step].				step := step bitShift: -1.				bit := bit bitShift: -1].			predictedDelta := predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted := predicted - predictedDelta]				ifFalse: [predicted := predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted := 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].			"compute new index and step values"			index := index + (indexTable at: delta + 1).			index < 0				ifTrue: [index := 0]				ifFalse: [index > 88 ifTrue: [index := 88]].			step := stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 4/23/2001 15:12'!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	"not yet implemented"	<inline: false>	self success: false.! !!Bitmap methodsFor: 'filing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:11'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	size := bm size.	i := self encodeInt: size in: ba at: 1.	k := 1.	[k <= size] whileTrue:		[word := bm at: k.		lowByte := word bitAnd: 16rFF.		eqBytes := ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j := k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j := j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i := self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i := i+1]				ifFalse: [i := self encodeInt: j-k+1*4+2 in: ba at: i.						i := self encodeBytesOf: word in: ba at: i].			k := j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i := self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i := i+1.				k := k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j := j+1].				j = size ifTrue: [j := j + 1].				"We have one or more unmatching words, ending at j-1"				i := self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i := self encodeBytesOf: (bm at: m) in: ba at: i].				k := j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n := rawBytes := myBytes := 0.Form allInstancesDo:	[:f | f unhibernate.	b := f bits.	n := n + 1.	rawBytes := rawBytes + (b size*4).	myBytes := myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:11'!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	i := index.  "byteArray read index"	end := ba size.	k := 1.  "bitmap write index"	pastEnd := bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt := ba at: i.  i := i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]				ifFalse: [anInt := 0.						1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].		n := anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code := anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data := ba at: i.  i := i+1.						data := data bitOr: (data bitShift: 8).						data := data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data := 0.						1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data := 0.							1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].							bm at: k put: data.  k := k+1]]]! !!Bitmap methodsFor: 'filing' stamp: 'jm (auto pragmas 12/08) 2/15/98 17:27'!encodeBytesOf: anInt in: ba at: i	"Copy the integer anInt into byteArray ba at index i, and return the next index"	<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	0 to: 3 do:		[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].	^ i+4! !!Bitmap methodsFor: 'filing' stamp: 'jm (auto pragmas 12/08) 2/15/98 17:26'!encodeInt: anInt in: ba at: i	"Encode the integer anInt in byteArray ba at index i, and return the next index.	The encoding is as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes"			<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	anInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].	anInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\256.  ^ i+2].	ba at: i put: 255.	^ self encodeBytesOf: anInt in: ba at: i+1! !!ByteArray class methodsFor: 'byte based hash' stamp: 'SqR (auto pragmas 12/08) 8/21/2002 16:21'!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!ByteString methodsFor: 'comparing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:12'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	<var: #string1 declareC: 'unsigned char *string1'>	<var: #string2 declareC: 'unsigned char *string2'>	<var: #order declareC: 'unsigned char *order'>	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString methodsFor: 'comparing' stamp: 'bf (auto pragmas 12/08) 8/31/2004 13:50'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:12'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	<var: #aString declareC: 'unsigned char *aString'>	<var: #inclusionMap  declareC: 'char *inclusionMap'>	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:13'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	<var: #aCharacter declareC: 'int anInteger'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:12'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	<var: #table  declareC: 'unsigned char *table'>	<var: #aString  declareC: 'unsigned char *aString'>	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!FMSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:22'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #waveTable declareC: 'short int *waveTable'>	doingFM := (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample := (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset := normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex := (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex := scaledOffsetIndex + scaledWaveTableSize].				scaledIndex := (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex := scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex := (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	count := count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #leftSamples declareC: 'short int *leftSamples'>	<var: #rightSamples declareC: 'short int *rightSamples'>	isInStereo := leftSamples ~~ rightSamples.	compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.	compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor.	i := (2 * startIndex) - 1.	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex := (scaledIndex := scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex := (scaledIndex := scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex := sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count := 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex := sampleIndex]				ifFalse: [nextSampleIndex := ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m := scaledIndex bitAnd: LoopIndexFractionMask.		rightVal := leftVal :=			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal :=				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		rightVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0].			compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.			compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor]].	count := count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #ring declareC: 'short int *ring'>	lastIndex := (startIndex + n) - 1.	scaledThisIndex := scaledNextIndex := scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex := scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex := ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average :=			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample := (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex := scaledNextIndex.		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	scaledIndex := scaledNextIndex.	count := count - n.! !!ReverbSound methodsFor: 'private' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:55'!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #tapDelays declareC: 'int *tapDelays'>	<var: #tapGains declareC: 'int *tapGains'>	<var: #leftBuffer declareC: 'short int *leftBuffer'>	<var: #rightBuffer declareC: 'short int *rightBuffer'>	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft := delayedRight := 0.		1 to: tapCount do: [:tapIndex |			i := bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i := i + bufferSize].  "wrap"			tapGain := tapGains at: tapIndex.			delayedLeft := delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight := delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j := (2 * sliceIndex) - 1.		out := (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j := j + 1.		out := (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex := (bufferIndex \\ bufferSize) + 1].! !!SampledSound methodsFor: 'playing' stamp: 'ar (auto pragmas 12/08) 2/3/2001 15:23'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #samples declareC: 'short int *samples'>	lastIndex := (startIndex + n) - 1.	outIndex := startIndex.    "index of next stereo output sample pair"	sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample := ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i := (2 * outIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * outIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].		scaledIndex := scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow := scaledIndex >> IncrementFractionBits.			indexHighBits := indexHighBits + overflow.			scaledIndex := scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex := outIndex + 1].	count := count - n.! !!SampledSound class methodsFor: 'utilities' stamp: 'ar (auto pragmas 12/08) 2/3/2001 16:14'!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	<var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'>	n := aByteArray size.	1 to: n do: [:i |		s := aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !